install.packages("signal", "oce")
# Returns a list
# freq_comps - A vector of normalized frequency components
# timestamps - A vector of time stamps/points
# frequencystamps - A vector of frequency stamps/points
# spectro_img - A spectrogram plot with desired input parameters
return(list(freq_comps = P, timestamps = t, frequencystamps = f, spectro_img = img))
# Data Stream Demeaning Function - 18th Nov 2021 - Version 1
# Demeaning Function
demeaner <- function(datastream){
# Checking for the Data Format
dimm <- dim(datastream)
if (len(dimm) != 1){
stop(paste("The provided data stream cannot be demeaned since it is not a vector"))
}
# Demeaning the Data Stream
demeaned_datastream <- datastream - mean(datastream)
return(demeaned_datastream)
}
# Returns a list
# data - A matrix or vector containing the data from the input .wav or Audio file
# signal - A vector representing the extracted signal (demeaned)
# samplingRate - A scalar corresponding to the Sampling Rate of the Signal
# duration - A scalar corresponding to the Duration of the Signal
return(list(data = data, signal = out_demeaned, samplingRate = fs, duration = dur))
wavsumm <- function(file_input, plot = TRUE){
# Extract demeaned Signal from Data
out <- wavread(file_input)
data <- out$signal
# Get the Summary Statistics of the demeaned Signal
summ <- summary(data)
# Check condition on plot and return a plot if needed
if (plot == TRUE){
# Plot a Line Plot representing the demeaned Signal
img <- plot(data, t="l")
return(list(summ = summ, img = img))
}
else{
return(summ = summ)
}
}
# Data Stream FFT Function - 21st Nov 2021 - Version 1
# FFT Function
# A vibration signal can be decomposed into its frequency components
# using the Fast Fourier Transform (FFT). Simply calling the R function fft
# returns data in an unfriendly format, but this function turns it into a more intuitive version
wavfft <- function(data, plot = TRUE){
datafft <- fft(data)
# Ignore the 2nd half, which are complex conjugates of the 1st half,
# and calculate the Mod (magnitude of each complex number)
amplitude <- Mod(datafft[1:(length(datafft)/2)])
# Calculate the frequencies
frequency <- seq(0, 10000, length.out=length(datafft)/2)
# Check condition on plot and return a plot if needed
if (plot == TRUE){
# Plotting
plot(amplitude ~ frequency, t="l")
return(list(data_FFT = amplitude, frequency = frequency, img = img))
}
else{
return(list(data_FFT = amplitude, frequency = frequency))
}
}
usethis::use_readme_rmd()
usethis::use_readme_rmd()
usethis::use_gpl3_license()
devtools::document()
rm(list = c("demeaner", "wavfft", "wavsumm"))
devtools::document()
install.packages("oce, signal, ggplot")
install.packages('devtools')
devtools::install_github('msuefishlab/tdmsreader')
# Data Stream (.tdms Format) Reading Function - 2nd Dec 2021 - Version 1
library(tdmsreader)
f = file('C/Users/Owner/Documents/MC_Off_1_Acc.tdms', 'rb')
# Data Stream (.tdms Format) Reading Function - 2nd Dec 2021 - Version 1
library(tdmsreader)
f = file('C/Users/Owner/Documents/MC_Off_1_Acc.tdms', 'rb')
main = TdmsFile$new(f)
main$read_data(f, 0, 1)
r = main$objects[[ "/'Untitled'/'Dev1/ai0'"]]
t = r$time_track(start = 0, end = 1)
s = r$data
png('out.png')
plot(t, s, xlab = 'Time', ylab = 'Volts')
title('TDMS reader')
dev.off()
close(f)
main = TdmsFile$new(f)
# Data Stream (.tdms Format) Reading Function - 2nd Dec 2021 - Version 1
library(tdmsreader)
f = file('tests/MC_Off_1_Acc.tdms', 'rb')
main = TdmsFile$new(f)
# Data Stream (.tdms Format) Reading Function - 2nd Dec 2021 - Version 1
library(tdmsreader)
f = file('tests/MC_Off_1_Acc.tdms', 'rb')
main = TdmsFile$new(f)
main$read_data(f, 0, 1)
r = main$objects[[ "/'Untitled'/'Dev1/ai0'"]]
t = r$time_track(start = 0, end = 1)
s = r$data
png('out.png')
plot(t, s, xlab = 'Time', ylab = 'Volts')
title('TDMS reader')
dev.off()
close(f)
# Data Stream (.tdms Format) Reading Function - 2nd Dec 2021 - Version 1
library(tdmsreader)
f = file('tests/MC_Off_1_Acc.tdms', 'rb')
main = TdmsFile$new(f)
main$read_data(f, 0, 1)
r = main$objects[[ "/'Untitled'/'Dev1/ai0'"]]
t = r$time_track(start = 0, end = 1)
s = r$data
png('out.png')
plot(t, s, xlab = 'Time', ylab = 'Volts')
title('TDMS reader')
dev.off()
close(f)
# Data Stream (.tdms Format) Reading Function - 2nd Dec 2021 - Version 1
library(tdmsreader)
f = file('tests/MC_Off_1_Acc.tdms', 'rb')
main = TdmsFile$new(f)
# Data Stream (.tdms Format) Reading Function - 2nd Dec 2021 - Version 1
library(tdmsreader)
f = file('tests/MC_Off_1_Acc.tdms', 'r')
main = TdmsFile$new(f)
main$read_data(f, 0, 1)
r = main$objects[[ "/'Untitled'/'Dev1/ai0'"]]
t = r$time_track(start = 0, end = 1)
s = r$data
png('out.png')
plot(t, s, xlab = 'Time', ylab = 'Volts')
title('TDMS reader')
dev.off()
close(f)
# Data Stream (.tdms Format) Reading Function - 2nd Dec 2021 - Version 1
library(tdmsreader)
f = file('tests/MC_Off_1_Acc.tdms', 'rb')
main = TdmsFile$new(f)
f
library(tdmsreader)
f = file('tests/MC_Off_1_Acc.tdms', 'rb')
main = TdmsFile$(f)
# Data Stream (.tdms Format) Reading Function - 2nd Dec 2021 - Version 1
library(tdmsreader)
f = file('tests/MC_Off_1_Acc.tdms', 'rb')
main = TdmsFile$f
main
main$read_data(f, 0, 1)
# Data Stream (.tdms Format) Reading Function - 2nd Dec 2021 - Version 1
library(tdmsreader)
f = file('tests/MC_Off_1_Acc.tdms', 'rb')
main = TdmsFile$new(f)
main$read_data(f, 0, 1)
# Data Stream (.tdms Format) Reading Function - 2nd Dec 2021 - Version 1
library(tdmsreader)
f = file('tests/MC_Off_1_Acc.tdms', 'rb')
main = TdmsFile$new(f)
close(f)
# Data Stream (.tdms Format) Reading Function - 2nd Dec 2021 - Version 1
library(tdmsreader)
f = file('tests/MC_Off_1_Acc.tdms', 'rb')
main = TdmsFile$new(f)
main$read_data(f, 0, 1)
r = main$objects[[ "/'Untitled'/'Dev1/ai0'"]]
t = r$time_track(start = 0, end = 1)
s = r$data
png('out.png')
plot(t, s, xlab = 'Time', ylab = 'Volts')
title('TDMS reader')
dev.off()
close(f)
# Data Stream (.tdms Format) Reading Function - 2nd Dec 2021 - Version 1
library(tdmsreader)
f = file('tests/MC_Off_1_Acc.tdms', 'rb')
close(f)
dev.off()
close(f)
# Data Stream (.tdms Format) Reading Function - 2nd Dec 2021 - Version 1
library(tdmsreader)
f = file('tests/MC_Off_1_Acc.tdms', 'rb')
main = TdmsFile$new(f)
# Data Stream (.tdms Format) Reading Function - 2nd Dec 2021 - Version 1
library(tdmsreader)
f = file('MC_Off_1_Acc.tdms', 'rb')
# Data Stream (.tdms Format) Reading Function - 2nd Dec 2021 - Version 1
library(tdmsreader)
f = file('tests/MC_Off_1_Acc.tdms', 'rb')
f
# Data Stream (.tdms Format) Reading Function - 2nd Dec 2021 - Version 1
library(tdmsreader)
f = file('tests/file.tdms', 'rb')
main = TdmsFile$new(f)
main$read_data(f, 0, 1)
r = main$objects[[ "/'Untitled'/'Dev1/ai0'"]]
t = r$time_track(start = 0, end = 1)
s = r$data
png('out.png')
plot(t, s, xlab = 'Time', ylab = 'Volts')
title('TDMS reader')
dev.off()
close(f)
# Data Stream (.tdms Format) Reading Function - 2nd Dec 2021 - Version 1
library(tdmsreader)
f = file('tests/file.tdms', 'rb')
main = TdmsFile$new(f)
main$read_data(f, 0, 1)
r = main$objects[[ "/'Untitled'/'Dev1/ai0'"]]
t = r$time_track(start = 0, end = 1)
s = r$data
png('out.png')
plot(t, s, xlab = 'Time', ylab = 'Volts')
title('TDMS reader')
dev.off()
close(f)
# Data Stream (.tdms Format) Reading Function - 2nd Dec 2021 - Version 1
library(tdmsreader)
f = file('tests/file.tdms', 'rb')
main = TdmsFile$new(f)
main$read_data(f, 0, 1)
r = main$objects[[ "/'Untitled'/'Dev1/ai0'"]]
t = r$time_track(start = 0, end = 50)
s = r$data
png('out.png')
plot(t, s, xlab = 'Time', ylab = 'Volts')
title('TDMS reader')
dev.off()
close(f)
# Data Stream (.tdms Format) Reading Function - 2nd Dec 2021 - Version 1
library(tdmsreader)
f = file('tests/file.tdms', 'rb')
main = TdmsFile$new(f)
main$read_data(f, 0, 1)
r = main$objects[[ "/'Untitled'/'Dev1/ai0'"]]
t = r$time_track(start = 0, end = 1)
s = r$data
png('out.png')
plot(t, s, xlab = 'Time', ylab = 'Volts')
title('TDMS reader')
dev.off()
close(f)
r
data
r$data
s
plot(s)
# Data Stream (.tdms Format) Reading Function - 2nd Dec 2021 - Version 1
# Reading and Manipulating .tdms files Functions
library(tdmsreader)
f = file('tests/file.tdms', 'rb')
main = TdmsFile$new(f)
main$read_data(f, 0, 1)
r = main$objects[[ "/'Untitled'/'Dev1/ai0'"]]
t = r$time_track(start = 0, end = 1)
s = r$data
dev.off()
close(f)
# Data Stream (.tdms Format) Reading Function - 2nd Dec 2021 - Version 1
# Reading and Manipulating .tdms files Functions
tdmsread <- function(file_input){
library(tdmsreader)
file_input = file('tests/file.tdms', 'rb')
main = TdmsFile$new(file_input)
main$read_data(file_input, 0, 1)
r = main$objects[[ "/'Untitled'/'Dev1/ai0'"]]
t = r$time_track(start = 0, end = 1)
s = r$data
dev.off()
close(f)
return(list(datastream = s, timestamps = t))
}
#' also calculations the summary of the data stream and plots it if specified.
#' @param file_input is an Wav file Input
#' @param plot A boolean which indicates if we want to plot the signal or not. It is TRUE by default.
#' @return The function returns a list containing:
#' \itemize{
#' \item summ - The summary of the extracted data stream
#' \item img - The plot of the data stream if plotting is specified as TRUE
#' }
#' @import tuneR
#' @export
wavsumm <- function(file_input, plot = TRUE){
# Extract demeaned Signal from Data
out <- wavread(file_input)
data <- out$signal
# Get the Summary Statistics of the demeaned Signal
summ <- summary(data)
# Check condition on plot and return a plot if needed
if (plot == TRUE){
# Plot a Line Plot representing the demeaned Signal
img <- plot(data, t="l")
return(list(summ = summ, img = img))
}
else{
return(summ = summ)
}
}
#' @param file_input is an Wav file Input
#' @return The function returns a list containing:
#' \itemize{
#' \item data - A matrix or vector containing the data from the input .wav or Audio file
#' \item signal - A vector representing the extracted signal (demeaned)
#' \item samplingRate - A scalar corresponding to the Sampling Rate of the Signal
#' \item duration - A scalar corresponding to the Duration of the Signal
#'}
#' @import tuneR
#' @export
wavread <- function(file_input){
# Extract Data from .wav File or Audio
data <- readWave(file_input)
# Determine Sample Rate
fs = data@samp.rate
# Extract Signal from Data
out <- data@left
# Demean the Data
out_demeaned <- demeaner(out)
# Determine Duration of the Signal
dur <- length(out)/fs
# Returns a list
# data - A matrix or vector containing the data from the input .wav or Audio file
# signal - A vector representing the extracted signal (demeaned)
# samplingRate - A scalar corresponding to the Sampling Rate of the Signal
# duration - A scalar corresponding to the Duration of the Signal
return(list(data = data, signal = out_demeaned, samplingRate = fs, duration = dur))
}
#' The destination/folder of the file must be specified and its associated
#' TDMS_Index file must be present in the same folder.
#' @param file_input is an TDMS file Input
#' @return The function returns a list containing:
#' \itemize{
#' \item datastream - A vector of data stream values based on the input TDMS file
#' \item timestamps - A vector of time stamps associated with the datastream based on the input TDMS file
#'}
#' @import tdmsreader
#' @export
tdmsread <- function(file_input){
#library(tdmsreader)
# Read in the TDMS File along with its destination
file_input <- file('tests/file.tdms', 'rb')
# Use the imported tdmsreader library to read the TDMS file
main <- TdmsFile$new(file_input)
# Extracting the First Channel and First Module in the TDMS file
main$read_data(file_input, 0, 1)
# Taking all streams associated with above specified Module and Channel
r <- main$objects[[ "/'Untitled'/'Dev1/ai0'"]]
# Extracting the Time stamps
t <- r$time_track(start = 0, end = 1)
# Extracting the Data stream values
s <- r$data
# Switching OFF function in case the Script runs based off a DAQ system
dev.off()
# Closing the TDMS file
close(f)
# Returns a list
# datastream - A vector of data stream values
# timestamps - A vector of time stamps/points
return(list(datastream = s, timestamps = t))
}
#' @param plot indicates whether the user wants to plot the data in the frequency domain or NOT. By default, it is TRUE
#' results in a plot representing the frequency domain of the data stream with various
#' frequency components
#' @return The function returns a list containing :
#'   \itemize{
#'   \item data_FFT - A vector of frequency components associated with the data stream
#'   \item frequency - A vector of frequencies associated with FFT on data stream
#'   \item img - A plot of the data in the frequency domain
#'}
#' @export
wavfft <- function(data, plot = TRUE){
datafft <- fft(data)
# Ignore the 2nd half, which are complex conjugates of the 1st half,
# and calculate the Mod (magnitude of each complex number)
amplitude <- Mod(datafft[1:(length(datafft)/2)])
# Calculate the frequencies
frequency <- seq(0, 10000, length.out=length(datafft)/2)
# Check condition on plot and return a plot if needed
if (plot == TRUE){
# Plotting
img <- plot(amplitude ~ frequency, t="l")
return(list(data_FFT = amplitude, frequency = frequency, img = img))
}
else{
return(list(data_FFT = amplitude, frequency = frequency))
}
}
# Data Stream Demeaning Function - 18th Nov 2021 - Version 1
# Demeaning Function
#' @title Data Stream Demeaner
#' @description The function aims to take a data stream in a vector form and returns the
#' demeaned data for further analysis. In short, the function calculates the mean of the
#' data and element-wise substracts it from the entire vector
#' @param datastream is a vector containing a one dimensional data stream
#' @return The function returns a vector containing the demeaned data stream
#' @export
demeaner <- function(datastream){
# Checking for the Data Format
dimm <- dim(datastream)
if (len(dimm) != 1){
stop(paste("The provided data stream cannot be demeaned since it is not a vector"))
}
# Demeaning the Data Stream
demeaned_datastream <- datastream - mean(datastream)
return(demeaned_datastream)
}
# Returns a list
# freq_comps - A vector of normalized frequency components
# timestamps - A vector of time stamps/points
# frequencystamps - A vector of frequency stamps/points
# spectro_img - A spectrogram plot with desired input parameters
return(list(freq_comps = P, timestamps = t, frequencystamps = f, spectro_img = img))
else{
P <- P
}
#' @param dbON is a Boolean indicating if we want to convert to decibels or NOT
#' @return The function returns a list containing :
#'   \itemize{
#'   \item freq_comps - A vector of normalized frequency components associated with the data stream
#'   \item timestamps - A vector of time stamps/points associated with the data stream spectrogram
#'   \item frequencystamps - A vector of frequency stamps/points associated with the data stream spectrogram
#'   \item spectro_img - A spectrogram plot with desired input parameters for the data stream
#'}
#' @import signal, oce, ggplot
#' @export
spectro <- function(x, n, Fs, window, overlap, dbON){
# Checks on dbON: Can only be 1 or 0
if (dbON != 0 || dbON != 1){
stop(paste("The parameter dbON can only take values 1 or 0"))
}
# Generate Spectrogram
spec <- specgram(x = snd, n = nfft, Fs = fs, window = window, overlap = overlap)
# Get rid of Phase Information
P <- abs(spec$S)
# Normalize
P <- P/max(P)
# Convert to dB if dbON = 1 and Ignore if dbON = 0
if (dbON == 1){
P <- 10*log10(P)
}
else{
P <- P
}
# Config the Time Axis
t <- spec$t
# Config the Frequency Axis
f <- spec$f
# Plot the Spectrogram
img = imagep(x = t,
y = f,
z = t(P),
col = oce.colorsViridis,
ylab = 'Frequency [Hz]',
xlab = 'Time [s]',
drawPalette = T,
decimate = F)
# Returns a list
# freq_comps - A vector of normalized frequency components
# timestamps - A vector of time stamps/points
# frequencystamps - A vector of frequency stamps/points
# spectro_img - A spectrogram plot with desired input parameters
return(list(freq_comps = P, timestamps = t, frequencystamps = f, spectro_img = img))
}
# Frequency Components Decomposition Function using the Fast Fourier Transform (FFT)
datafreq <- function(data, frequencyPoints = 10000){
ts <- tdmsread(data)
ts_data <- ts$datastream
data_fft <- fft(ts_data)
# Ignore the 2nd half, which are complex conjugates of the 1st half,
# and calculate the Mod (magnitude of each complex number)
amplitude <- Mod(data_fft[1:(length(data_fft)/2)])
# Calculate the frequencies
frequency <- seq(0, frequencyPoints, length.out=length(data_fft)/2)
# Plot!
img <- plot(amplitude ~ frequency, t="l")
# Return the Plot of TS data in the Frequency Domain
return(img)
}
# Frequency Components Decomposition Function using the Fast Fourier Transform (FFT)
#' @title Frequency Components Decomposition Function
#' @description The function reads in a TDMS file and generates its Fast Fourier Transform (FFT). For
#' the FFT calculation, we ignore the complex conjugates involved and only consider the Magnitudes of each
#' complex number.
#' @param data is an TDMS file Input
#' @param frequencyPoints corresponds to the number of points for FFT
#' @return The function returns the plot of the TDMS file data signal in the Frequency Domain
#' @import tdmsreader
#' @export
datafreq <- function(data, frequencyPoints = 10000){
ts <- tdmsread(data)
ts_data <- ts$datastream
data_fft <- fft(ts_data)
# Ignore the 2nd half, which are complex conjugates of the 1st half,
# and calculate the Mod (magnitude of each complex number)
amplitude <- Mod(data_fft[1:(length(data_fft)/2)])
# Calculate the frequencies
frequency <- seq(0, frequencyPoints, length.out=length(data_fft)/2)
# Plot!
img <- plot(amplitude ~ frequency, t="l")
# Return the Plot of TS data in the Frequency Domain
return(img)
}
rm(list = ls())
rm(list = ls())
install.packages("signal", dependencies = TRUE)
rm(list = ls())
rm(list = ls())
install.packages("ggplot2", dependencies = TRUE)
rm(list = ls())
library(readTDMS)
